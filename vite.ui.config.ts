import { defineConfig, Plugin, PluginOption } from "vite";
import react from "@vitejs/plugin-react";
import { viteSingleFile } from "vite-plugin-singlefile";
import { nodePolyfills } from "vite-plugin-node-polyfills";
import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
import { join, resolve } from "path";
import { uiMap } from "./src/ui/registry/uiMap.js";

const componentsDir = resolve(__dirname, "src/ui/components");
// Use node_modules/.cache for generated HTML entries - these are build artifacts, not source files
const entriesDir = resolve(__dirname, "node_modules/.cache/mongodb-mcp-server/ui-entries");
const templatePath = resolve(__dirname, "src/ui/build/template.html");
const mountPath = resolve(__dirname, "src/ui/build/mount.tsx");
const generatedModulePath = resolve(__dirname, "src/ui/generated/uiHtml.ts");
const uiDistPath = resolve(__dirname, "dist/ui");

// Unique component names from uiMap - only these will be built
const components = [...new Set(Object.values(uiMap))];

/**
 * Vite plugin that generates HTML entry files for each mapped component
 * based on the template.html file.
 *
 * Only builds components that are referenced in uiMap.
 */
function generateHtmlEntries(): Plugin {
    return {
        name: "generate-html-entries",
        buildStart() {
            const template = readFileSync(templatePath, "utf-8");

            if (!existsSync(entriesDir)) {
                mkdirSync(entriesDir, { recursive: true });
            }

            for (const componentName of components) {
                // Verify the component exists
                const componentPath = join(componentsDir, componentName, "index.ts");
                if (!existsSync(componentPath)) {
                    throw new Error(
                        `Component "${componentName}" referenced in uiMap but not found at ${componentPath}`
                    );
                }

                const html = template
                    .replace("{{COMPONENT_NAME}}", componentName)
                    .replace("{{TITLE}}", componentName.replace(/([A-Z])/g, " $1").trim()) // "ListDatabases" -> "List Databases"
                    .replace("{{MOUNT_PATH}}", mountPath);

                const outputPath = join(entriesDir, `${componentName}.html`);
                writeFileSync(outputPath, html);
                console.log(`[generate-html-entries] Generated ${componentName}.html`);
            }
        },
    };
}

/**
 * Vite plugin that generates the uiHtml.ts module after the build completes.
 * This embeds all built HTML strings into a TypeScript module so they can be
 * imported at runtime.
 *
 * Uses the uiMap from src/ui/registry/uiMap.ts to map tool names to component HTML files.
 */
function generateUIModule(): Plugin {
    return {
        name: "generate-ui-module",
        closeBundle() {
            if (!existsSync(uiDistPath)) {
                console.warn("[generate-ui-module] dist/ui not found, skipping module generation");
                return;
            }

            const entries: Record<string, string> = {};

            // Use uiMap to determine which tools get which UI
            for (const [toolName, componentName] of Object.entries(uiMap)) {
                const htmlFile = join(uiDistPath, `${componentName}.html`);
                if (!existsSync(htmlFile)) {
                    console.warn(
                        `[generate-ui-module] HTML file not found for component "${componentName}" (tool: "${toolName}")`
                    );
                    continue;
                }
                const html = readFileSync(htmlFile, "utf-8");
                entries[toolName] = html;
            }

            const moduleContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is generated by the UI build process (vite build --config vite.ui.config.ts).
 * It contains the bundled HTML strings for each UI component, keyed by tool name.
 *
 * To add a new UI:
 * 1. Create a component in src/ui/components/YourComponent/
 * 2. Add the mapping in src/ui/registry/uiMap.ts
 * 3. Run \`pnpm build:ui\` to regenerate this file
 */
export const uiHtml: Record<string, string> = ${JSON.stringify(entries, null, 4)};
`;

            writeFileSync(generatedModulePath, moduleContent);
            console.log(
                `[generate-ui-module] Generated uiHtml.ts with ${Object.keys(entries).length} UI(s): ${Object.keys(entries).join(", ")}`
            );
        },
    };
}

export default defineConfig({
    root: entriesDir,
    plugins: [
        generateHtmlEntries(),
        nodePolyfills({
            include: ["buffer", "stream"],
            globals: {
                Buffer: true,
            },
        }) as unknown as PluginOption,
        react(),
        viteSingleFile({
            removeViteModuleLoader: true,
        }),
        generateUIModule(),
    ],
    build: {
        outDir: resolve(__dirname, "dist/ui"),
        emptyOutDir: true,
        rollupOptions: {
            input: Object.fromEntries(components.map((name) => [name, resolve(entriesDir, `${name}.html`)])),
            output: {
                inlineDynamicImports: false,
            },
        },
        assetsInlineLimit: 100000000,
        sourcemap: false,
        minify: "esbuild",
    },
    resolve: {
        alias: {
            "@ui": resolve(__dirname, "src/ui"),
        },
    },
});
