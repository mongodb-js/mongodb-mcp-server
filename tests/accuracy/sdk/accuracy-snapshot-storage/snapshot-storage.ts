import z from "zod";

const LLMToolCallSchema = z.object({
    toolCallId: z.string(),
    toolName: z.string(),
    parameters: z.record(z.string(), z.unknown()),
});
export type LLMToolCall = z.infer<typeof LLMToolCallSchema>;

const ExpectedToolCallSchema = LLMToolCallSchema.omit({ toolCallId: true });
export type ExpectedToolCall = z.infer<typeof ExpectedToolCallSchema>;

export const AccuracyRunStatus = {
    Done: "done",
    Failed: "failed",
    InProgress: "in-progress",
} as const;

export type AccuracyRunStatuses = (typeof AccuracyRunStatus)[keyof typeof AccuracyRunStatus];

export const AccuracySnapshotEntrySchema = z.object({
    /**
     * A unique id for each accuracy run. Should either be generated by the
     * script triggering the accuracy run or provided via environment variables.
     * */
    accuracyRunId: z.string(),

    /**
     * Represents the status of accuracy run. Each test completion, during an
     * accuracy run, is supposed to submit an accuracy snapshot entry with
     * InProgress status which then later, after completion of accuracy run, is
     * updated to either Done or Failed, depending on whether there were errors
     * during the run or not. */
    accuracyRunStatus: z
        .enum([AccuracyRunStatus.Done, AccuracyRunStatus.Failed, AccuracyRunStatus.InProgress])
        .default(AccuracyRunStatus.InProgress),

    /** Timestamp of when this snapshot entry was generated. */
    createdOn: z.number(),

    /** The commit SHA for which the accuracy run was triggered. */
    commitSHA: z.string(),

    /** The LLM provider providing the LLM APIs */
    provider: z.string(),

    /** The LLM which was requested to respond to our test prompts */
    requestedModel: z.string(),

    /** The actual prompt that was provided to LLM as test */
    prompt: z.string(),

    /** A number between 0 and 1, representing how accurately the expected tools
     * were called by LLM when responding to the provided prompts. To know more
     * about how this number is generated, check - toolCallingAccuracy.ts */
    toolCallingAccuracy: z.number(),

    /**
     * A list of tools, along with their parameters, that are expected to be
     * called by the LLM in test. */
    expectedToolCalls: ExpectedToolCallSchema.array(),

    /**
     * A list of tools, along with their parameters, that were actually called
     * by the LLM in test. */
    actualToolCalls: LLMToolCallSchema.array(),

    /**
     * The total time taken by LLM to respond to our prompt. */
    llmResponseTime: z.number(),

    /**
     * Token usage data, returned as part of LLM prompt response. */
    tokensUsage: z
        .object({
            promptTokens: z.number().optional(),
            completionTokens: z.number().optional(),
            totalTokens: z.number().optional(),
        })
        .optional(),

    /**
     * The ID of the model that actually responded to our prompt request. */
    respondingModel: z.string(),

    /**
     * The final response text generated by the LLM, in response to our prompt
     * request. */
    text: z.string(),

    /**
     * A list of messages, exchanged between LLM and our testing agent, in
     * response to our prompt request. This is particularly helpful for
     * debugging. */
    messages: z.array(z.record(z.string(), z.unknown())),
});

export type AccuracySnapshotEntry = z.infer<typeof AccuracySnapshotEntrySchema>;

export interface AccuracySnapshotStorage {
    createSnapshotEntry(
        snapshotEntry: Pick<
            AccuracySnapshotEntry,
            | "accuracyRunId"
            | "commitSHA"
            | "provider"
            | "requestedModel"
            | "prompt"
            | "toolCallingAccuracy"
            | "expectedToolCalls"
            | "actualToolCalls"
            | "llmResponseTime"
            | "tokensUsage"
            | "respondingModel"
            | "text"
            | "messages"
        >
    ): Promise<void>;

    getLatestSnapshotForCommit(commit: string): Promise<AccuracySnapshotEntry[]>;

    getSnapshotForAccuracyRun(accuracyRunId: string): Promise<AccuracySnapshotEntry[]>;

    updateAccuracyRunStatus(accuracyRunId: string, status: AccuracyRunStatuses): Promise<void>;

    close(): Promise<void>;
}
